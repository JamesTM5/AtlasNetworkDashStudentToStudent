---
title: "SSNetworkDash.RMD"
output:   flexdashboard::flex_dashboard:
    orientation: columns
    social: menu
    vertical_layout: fill
    css: gaugeAdjustment.css
runtime: shiny
---

```{r setup, include=FALSE}
# Install packages not yet installed and load each
devtools::install("C:/Users/jbeng/Documents/RF/RA")
library(RA)
packages = c("xlsx", "igraph", "networkD3", "openxlsx", "dplyr",
             "flexdashboard", "DT", "shiny", "tidyverse", "knitr", "dendextend", "plotly")
installed_packages <- packages %in% rownames(installed.packages())
if (any(installed_packages == FALSE)) {
  install.packages(packages[!installed_packages])
}
invisible(lapply(packages, library, character.only = TRUE))

#Read in network question details
source("SSSurveyConfig.R")
#Read in client/project metadata
source("SSClientConfig.R")

set.seed (seed)

#import the dashboard data
nodes <- xlsx::read.xlsx(dataFile, sheetIndex = 1)
edgesSSNQ <- xlsx::read.xlsx(dataFile, sheetIndex = 2)

#store node information unpruned separately for later comparative use
unprocessedNodes <- nodes

edgesSSNQNumeric <- makeResponseNumeric(edgesSSNQ,
                                        answersSSNQ,
                                        responseColumn =
                                        responseColumnSSNQ)

#prune edges to only the most positive
edgesSSNQNumericFiltered <- dplyr::filter(edgesContactVolumeNumeric, 
                                           edgesContactVolumeNumeric$numericScoreList > 
                                             thresholdForEdgeDrawing)

#list all the question data in order to loop the network analysis over them.
surveyData <- list(edgesSSNQNumericFiltered)

source("networkSurveyAnalysis.R")

totalNetworkInfo[[length(totalNetworkInfo)+1]] <-
  surveyDataAnalysis(questionData = surveyData[[1]])

# totalNetwork Info (for each question):
#  1. Degree In
#  2. Degree Out
#  3. Degree all
#  4. Diameter
#  5. Edge Density
#  6. Reciprocity
#  7. Hub Score
#  8. Authority Score
#  9. Key Relationships
#  10. Closeness
#  11. Isolates

source("calculateHomophyly.R")
homophylySSNQ <- calculateHomophyly(
                                homophylyEdgeList = edgesSSNQNumeric,
                                anonymous = anonymous,
                                socioDemographicVariable =
                                  socioDemographicVariables,
                                nodes = nodes)

# Format Socio-Demographic Variables info
predictiveSDVSSNQ <- levels(as.factor(unlist(homophylySSNQ[[1]])))
nonPredictiveSDVSSNQ <- levels(as.factor(unlist(homophylySSNQ[[2]])))
if(length(predictiveSDVSSNQ > 0)) {
  predictiveSDVSSNQFormatted <- 
    formatDataForDisplay(predictiveSDVSSNQ)
}

if(length(nonPredictiveSDVSSNQ > 0)) {
  nonPredictiveSDVSSNQFormatted <- 
    formatDataForDisplay(nonPredictiveSDVSSNQ)
}

#find isolates
isolatesSSNQ <- nodes$id [!(nodes$id %in% totalNetworkInfo[[1]][[3]][["People"]])]

#make a colour palette
colourPalette <- defineColourPalette()
listOfColours <- colourPalette[[2]]
colorJS <- colourPalette[[1]]

#Make an igraph object for each question
SSNQGraphFromDataset <- data.frame(
  edgesSSNQNumericFiltered$source,
  edgesSSNQNumericFiltered$target,
  ... = edgesSSNQNumericFiltered$numericScoreList)
SSNQGraph <- graph_from_data_frame(SSNQGraphFromDataset, directed = T)

# Perform Communities Analysis for each igraph object
SSNQCommunitiesData <- cluster_walktrap(SSNQGraph)
SSNQMembers <- membership(SSNQCommunitiesData)

#construct raw data for display clientside.
if(dataSource == "Polinode") {
    processedNodes <- select(unprocessedNodes, -c(x,y, size, color, List, Size))
    for(i in 1:length(names(processedNodes))) {
      names(processedNodes)[i] <- chartr(".", " ", names(processedNodes)[i])
      if (nchar(names(processedNodes[i])) > 12) {
        names(processedNodes)[i] <- abbreviate(names(processedNodes)[i], minlength=7, strict = TRUE)
      }
    }
}

numberOfGroups <- cliquiness(SSNQMembers, 3)

#TODO: determine summary score valueBox input from data

#TODO: commentary processing

source("generatePolar.R")
source("generateDegreeHistogram.R")
degreeAllHistogram <- generateDegreeHistogram(totalNetworkInfo[[1]][[3]])
degreeInHistogram <- generateDegreeHistogram(totalNetworkInfo[[1]][[1]])
degreeOutHistogram <- generateDegreeHistogram(totalNetworkInfo[[1]][[2]])

```

Overview
=======================================================================
  
Headlines {data-width=200}
--------------------------------------------------------------------------

### Network Health

```{r}

#valueBox(
#  overallHealth[1],
#  color = overallHealth[2],
#  icon = "fa-file-medical"
#)
```

### Potential for Improvement

```{r}

#valueBox(
#  overallPfI[1],
#  color = overallPfI[2],
#  icon = "fa-chart-line"
#)
```

### Motivation to Improve

```{r}

#valueBox(
#  overallMfI[1],
#  color = overallMfI[2],
#  icon = "fa-seedling"
#)
```


### Our Commentary

  The data shown here is a result of analysis conducted upon the social
   network data provided by completing our Relationships Foundation
   Questionnaires, along with any other information provided to us by you
   and/or `r clientName`.

  Our analysis assesses this class to be...
  
Row {data-width=250}
-----------------------------------------------------------------------

### Class Diameter

```{r}
diameter <- totalNetworkInfo[[1]][[4]]

# derive sector colours for gauge from nrow(nodes) and whether
# the graph is fragmented

if(length(CDSSNQ[!CDSSNQ==0])>1) {
  customSectors <-  gaugeSectors (
    danger = c(0, 100)
  )
} else {
  customSectors <-  gaugeSectors (
    success = c(0,(nrow(nodes)/6)),
    warning = c((nrow(nodes)/6), (nrow(nodes)/4)),
    danger = c((nrow(nodes)/4), (nrow(nodes)/2)))
}

#make gauge
gauge(round(diameter, digits = 2), min = 1, max = (nrow(nodes)/2), sectors = customSectors)

#provide warning text if graph is fragmented.
if (graphConnected(SSNQGraph)) {
  SSNQConnectedWarning <- paste("However, as this group is split across ",
    "separate unconnected sub-groups, this may not be a good measure of group ",
    "cohesiveness.",
    sep = "")
} else {
  SSNQConnectedWarning <- ""
}
```
 
> the most distant people are `r round(diameter, digits=0)` relationships away
from each other. <span style="color: red;">`r SSNQConnectedWarning`</span> 


### Class Edge Density

```{r}
edgeDensity <- totalNetworkInfo[[1]][[5]]
gauge(round(edgeDensity, digits = 2), min = 0, max = 1, gaugeSectors(
    success = c(0.6, 1), 
    warning = c(0.4, 0.59), 
    danger = c(0, 0.39)
  ))
```
  
> `r round(edgeDensity, digits = 2)*100`% of all possible relationships are
strongly positive.
  
### Class Reciprocity
  
```{r}
reciprocity <- totalNetworkInfo[[1]][[6]]
gauge(round(reciprocity, digits = 2), min = 0, max = 1, gaugeSectors(
    success = c(0.6, 1), 
    warning = c(0.4, 0.59), 
    danger = c(0, 0.39)
  ))
```

> Both parties agreed on a relationship status
`r round(reciprocity, digits = 2)*100`% of the time.

### Class Predictive Factors

<center>
```{r, results = 'asis'}
if (length(predictiveSDVSSNQ > 0)) {
  cat(predictiveSDVSSNQFormatted)
} else {
  cat("None")
}
```
</center>

>These factors statistically significantly influence the nature and function of
the network

### Class Non-Predictive Factors

<center>
```{r, results = 'asis'}
if (length(nonPredictiveSDVSSNQ > 0)) {
  cat(nonPredictiveSDVSSNQFormatted)
} else {
  cat("None")
}
```
</center>

>These factors do not statistically significantly influence the nature and
function of the network


Network Maps 
----------------------------------------------------------------

### Summary graph {.no-padding}

```{r}
#generate a D3 graph for the center upper panel
#Convert igraph to D3
SSNQNetworkD3 <- igraph_to_networkD3(SSNQGraph, group = SSNQMembers)

#Write out D3 Graph
forceNetwork(Links = SSNQNetworkD3$links,
             Nodes = SSNQNetworkD3$nodes,
             Source = 'source',
             Target = 'target',
             NodeID = 'name',
             Group = 'group',
             zoom = TRUE,
             #linkDistance = 100,
             colourScale = colorJS,
             height = 500,
             width = NULL,
             fontSize = 14,
             fontFamily = "serif",
             linkWidth = JS("function(d) { return Math.sqrt(d.value); }"),
             radiusCalculation = JS(" Math.sqrt(d.nodesize)+6"),
             charge = -120,
             linkColour = "#666",
             opacity = 1
             )
             
```

> This graph represents all the most productive relationships in the network.  Each dot is a person, and each edge is a productive relationship.  The colours indicate cliques, or subgroups in the data which naturally form as people work together. zoom using the scroll wheel or pinch on a touchscreen device, and drag people around to see who is connected most closely to them.

### Class Communities Dendrogram
<center>
```{r}

SSNQDend <- as.dendrogram(SSNQCommunitiesData)
plot(SSNQDend, horiz = TRUE)

```
</center>

> The 'tree and leaf' dendrogram shows how the network is split into subgroups.  The higher the number, and further leftward the split, the bigger the distance between the group members.

Key Network Information {data-width=250}
-----------------------------------------------------

### Class 'Hubs' {data-height=350} 

<center>
```{r, results = 'asis'}

#FROM HERE CODE IS NOT FOR SSNQ YET AND NEEDS EDITING APPROPRIATELY

if (length(as.character(HSContactVolumeFormatted) > 0)) {
  cat(HSContactVolumeFormatted)
} else {
  cat("Contact Volume Hub Analysis Encountered an Error")
}
```
</center>

> These people are the social lifeblood of the network:  Removing them will
hamper communication and they make good contacts for new members to get more
involved.

### Class 'Authorities' {data-height=350} 

<center>
```{r, results = 'asis'}

if (length(as.character(ASContactVolume) > 0)) {
  cat(ASContactVolumeFormatted)
} else {
  cat("Network Authority Analysis Encountered an Error")
}
```
</center>

>These people are those people go to when they need advice or guidance:  They
have high value to others in the group.

### Fundamental Relationships  {data-height=750}

<center>
```{r, results = 'asis'}
firstRelationship <- paste(totalNetworkInfo[[1]][[9]][1,1], "<br>", "and<br>", totalNetworkInfo[[1]][[9]][1,2])
cat(firstRelationship)
```

***

```{r, results = 'asis'}
cat(paste(totalNetworkInfo[[1]][[9]][2,1], "<br>", "and<br>", totalNetworkInfo[[1]][[9]][2,2]))
```

***

```{r, results = 'asis'}
cat(paste(totalNetworkInfo[[1]][[9]][3,1], "<br>", "and<br>", totalNetworkInfo[[1]][[9]][3,2]))
```
</center>

>These are the relationships which make the group operate as it does.  Promoting
these adds cohesion.

### Network Isolates

<center>
```{r, results = 'asis'}
cat(isolatesSSNQ)
```
</center>

>These people are not joined to any others in the network by positive
relationships in at least one of the dimensions they were asked about.
